
<p align="center">
   基于SpringBoot+Mysql + Redis + RabbitMQ +MyBatis-Plus + Maven + Linux
+ Jmeter开发的秒杀/高并发解决方案
</p>

<p align="center">
   <a target="_blank" href="https://github.com/ttkican/Blog">
      <img src="https://img.shields.io/badge/JDK-8-green"/>
      <img src="https://img.shields.io/badge/springboot-2.7.0-green"/>
      <img src="https://img.shields.io/badge/react-green"/>
      <img src="https://img.shields.io/badge/mysql-5.7-green"/>
      <img src="https://img.shields.io/badge/mybatis--plus-3.5.2-green"/>
      <img src="https://img.shields.io/badge/redis-6.2.6-green"/>
   </a>
</p>


## 本地运行

1. MySQL版本为`5.7`
2. JDK版本为`8.0`   
3. 修改后端配置文件中的数据库等连接信息

## 项目介绍

1、秒杀/高并发 其实主要解决两个问题，一个是并发读，一个是并发写

2、并发读的核心优化理念是尽量减少用户到 DB 来"读"数据，或者让他们读更少的数据, 并
发写的处理原则也一样

3、针对秒杀系统需要做一些保护，针对意料之外的情况设计兜底方案，以防止最坏的情况
发生。

4、系统架构要满足高可用: 流量符合预期时要稳定，要保证秒杀活动顺利完成，即秒杀商品
顺利地卖出去，这个是最基本的前提

5、系统保证数据的一致性: 就是秒杀 10 个 商品 ，那就只能成交 10 个商品，多一个少一
个都不行。一旦库存不对，就要承担损失。

6、系统要满足高性能: 也就是系统的性能要足够高，需要支撑大流量, 不光是服务端要做极
致的性能优化，而且在整个请求链路上都要做协同的优化，每个地方快一点, 整个系统就"快
"了

7、秒杀涉及大量的并发读和并发写，因此支持高并发访问这点非常关键, 对应的方案比如页
面缓存方案、Redis 预减库存/内存标记与隔离、请求的削峰(RabbitMQ/异步请求)、分布式
Session 共享等

## 技术介绍

SpringBoot+Mysql + Redis +
RabbitMQ +MyBatis-Plus + Maven + Linux + Jmeter


## 页面优化

### 1、需求说明
1) 多用户在查看商品列表和商品详情的时候, 每一个用户都需要到 DB 查询
2) 对 DB 查询的压力很大，比如 10000 人, 在 1 分钟都查看商品列表, 就会有 10000 次对
   DB 操作
3) 但是我们商品信息并不会频繁的变化, 所以你查询回来的结果都是一样的

### 2.解决方案   
 我们可以通过 Redis 缓存页面来进行优化, 这样可以将 1 分钟内多次查询 DB, 优化成 1
   次查询, 减少 DB 压力

## 超卖和复购

### 1、需求说明
当多用户在高并发秒杀商品时, 不能出现超卖和生成多条订单

### 2.解决方案
将生成的秒杀订单,存入 redis, 这样在查询某个用户是否已经秒杀过该商品
时, 就不用到数据库去查询，而是直接从 redis 去查询，起到优化的作用

如果在短时间内，大量抢购冲击 DB, 造成洪峰, 容易压垮数据库，判断商品是否还有库存时，使用 Redis 完成预减库存，减小对 DB 的压力

## 优化秒杀： 内存标记，实现空库存高速返回结果
### 1、需求说明
如果某个商品库存已经为空了, 我们仍然是到 Redis 去查询的, 还可以进行优化

### 2.解决方案
在本机jvm的map记录所有秒杀商品是否还有库存(操作本机jvm快于操作Redisw), 在执行预减库存时，先去map查询该秒杀商品是否还有库存，如果库存为空, 直接返回, 避免总是到 Redis 查询库存，大幅提高系统秒杀性能


## 优化秒杀: 加入消息队列，实现秒杀的异步请求(削峰填谷)
### 1、需求说明
前面秒杀, 没有实现异步机制, 是完成下订单后, 再返回的, 当有大并发请求下订单操作
  时, 数据库来不及响应, 容易造成线程堆积

### 2.解决方案
- 加入消息队列，实现秒杀的异步请求
- 接收到客户端秒杀请求后，服务器立即返回 正在秒杀中.., 有利于流量削峰
- 客户端进行轮询秒杀结果, 接收到秒杀结果后，在客户端页面显示即可

## 秒杀安全优化
### 问题分析
- 前面我们处理高并发, 是按照正常业务逻辑处理的, 也就是用户正常抢购
- 还需要考虑抢购安全性, 当前程序, 抢购接口是固定, 如果泄露, 会有安全隐患, 比如抢
  购未开始或者已结束, 还可以使用脚本发起抢购.
### 解决方案
- 隐藏抢购接口
- 用户抢购时, 先生成一个唯一的抢购路径, 返回给客户端
- 客户端抢购时 会携带生成的抢购路径, 服务端做校验, 如果校验成功, 才走下一步, 否
  则直接返回
  
## Redis分布式锁探讨
### 问题分析
- 在进行秒杀时，我们使用了一个关键的方法, Long decrement = redisTemplate.opsForValue().decrement("seckillGoods:" + goodsId);
-  decrement 方法具有原子性和隔离性, 所以有效的控制了抢购
- 所以在本项目中, 不使用 Redis 分布式锁, 也是可以控制抢购不出现 超购和复购
- 在开发中, 考虑到业务可能比较复杂综合, 不是一个 redis 操作(decrement)就可以完成的, 比
  如还需要进行修改操作(set), 甚至还会操作 DB, 文件， 第三方数据源等.  这时我们就需要扩大代码隔离性范围, 可以考虑使用 Redis 分布式锁

### 解决方案
-  获取锁，setnx ,得到一个 uuid 值，作为锁的值
-  线程获取锁成功、就执行相应业务
-  获取锁失败、返回信息, 这次抢购失败,请继续抢购


## 运行环境

**服务器：** CentOS7.6


## 开发环境

| 开发工具              | 说明               |
| --------------------- | ----------------- |
| IDEA                  | Java 开发工具 IDE  |
| Redis Desktop Manager | Redis 远程连接工具 |
| Xshell                | Linux 远程连接工具 |
| Xftp                  | Linux 文件上传工具 |

| 开发环境      | 版本   |
| ------------- | ------ |
| OpenJDK       | 8     |
| MySQL         | 5.7+  |
| Redis         | 6.2.6  |
| RabbitMq      | 3
